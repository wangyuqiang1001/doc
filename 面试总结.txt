浙江电子口岸公司:
一： 索引失效情况
1：比如如果是复合索引，要遵守左前缀原则，即从最左边开始，且连续，不能跳，可以不全，
2:在索引列上作函数计算操作，手动或者自动类型转换，，可能导致索引失败而全表扫描。
3:使用!=或者是<>的时候，无法使用索引，使用is not null 或者is null的时候将导致索引失效。
4:like使用%开头，将导致索引失效全表扫描
5:字符串加上单引号会导致索引失效
6:使用or将导致索引失效
7:联合索引中的列使用范围将会失效
二： 乐观锁悲观锁在项目中的实际运用
悲观锁：实际上这里有个误区，mysql默认隔离级别。可重复读是不会有线程安全问题的，但是
比如我们两个线程同时读取同一行数据，然后基于此更新，这就有问题了，select 默认是不会阻塞的
也就是即便你两个线程开启事务，先查询同一条数据，然后基于此修改，比如当前number是3，然后
两个线程同时对number进行自加操作的话，那么可能会获取4,这时我们需要使用select ....for update
操作，相当于一个排它锁，然后只有等待第一个线程或者事务执行完毕以后才会进行第二个。
乐观锁:一般采用一个version版本号控制，其实大概的意思就是比如商品库存的话，AB两个事务同时减库存，
但是可能还是上面的问题，这样的话使用一个版本号 ，先查出来的，然后更新的时候将版本号加1，这时候
B事务也要更新，但是B事务更新的前提是B事务获取的Version值自加1必须大于当前数据库的version值。
如果相等，代表A事务已经完成更新。update t_goods   set status=2,version=version+1  
where id=#{id} and version=#{version}; 
三: spring中事务的常见配置



四： cookie和session的联系和区别
cookie服务器端生成，保存在客户端中，安全性较差， 可以由客户端禁用，一般用来保存用户账号密码的加密信息，
客户端可以禁用cookie，cookie中还可以保存sessionID,用来标志用户，因为http是无状态的， 而为了要标记用户以及
具体权限或者等信息，就使用cookie加sesssion结合，来存放用户信息。避免每次访问都生成一个session，在调用
request.getsession()的时候生成session,内部实现实际是一个线程安全的容器，然后服务器自身会将这个sessionID写入
cookie中返回给客户端。这种在单机 模式中是没有问题的，但是现在一般一个服务使用集群的话，因为 session是依赖于
tomcat实例的。在不同的tomcat中，比如A用户这个请求第一次访问了服务器A，第二次访问了服务器B,这样会导致在服务器
中找不到这个session实例，较为合适的解决办法一般有几种，(1)将session保存到第三缓存，比如redis.或者memerche中，
(2)基于tomcat的session服务， 也就是所有的tomcat实例都拥有所有的session信息，个人觉得不合适，因为总的来说这样
对内存消耗太大。（3）就是nginx基于 ip hash ,不同用户的请求，会经过hash算法到同一个服务器上，但是这种方式貌似
也不好，如果这个节点挂了呢。那这个用户不是玩完了。其实无论是session+cookie或者是现在项目中使用的基于token验证方式
的jwt总的来说都是为了解决http无状态这个问题，即如何更好的标志用户请求，基于token方式的话，很显然，可用性好，不比
再为 session共享等问题烦扰，直接基于token验证，这个规则在所有的节点都是一样的。
五：跨域问题
详见：跨域.md





