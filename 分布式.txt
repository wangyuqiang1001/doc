一:分布式介绍:
1:cap理论:c一致性，a高可用性，p分区容错性，任何分布式系统都只能满足其中两点,
满足ca，即是一致性和高可可用性，牺牲分区容错性子系统（不分区）,(实际上更多的是指分区子系统保持ca)(不分区当前就不需要在各节点之间同步)
满足cp, 即一致性和分区容错性，这样也是可以的，即在各个server之前需要同步保持一致性，传统关系型数据库的分布式事务大于基于此，
满足ap,即高可用性和分区容错性，众多nosql基于此，每个节点只为本地数据提供服务，
2:事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。
3:事务的四大特征:
原子性:构成事务的操作，要么全都执行，要么全都不执行，
一致性:事务执行前后，数据库一致性没有被破坏，A加钱，B减钱，
隔离性：并行发生的事务之间是不可见的。
永久性：事务一旦成功执行，那么便永远存在，且不会回滚
4:事务的类型：
本地事务:更多依赖于关系型数据库自带的事务机制，
分布式事务:更多依赖于服务之间的远程调用协作，如订服务和库存服务，
5:分布式事务产生的场景:
微服务之间的调用
单体系统访问多个数据库实例
多个微服务访问单体系统（对于后两个例子而言，都是一样的，如订单和库存，订单加，库存减少，
单个操作依靠数据库事务是成立的，但是顺序执行就需要考虑事务）
关于cap理论阐述:https://blog.csdn.net/chen77716/article/details/30635543
二：分布式锁:
分布式锁的实现方式:
1:基于关系型强事务支持数据库方式,将方法名作唯一约束，成功插入的方法获取锁，执行完成后删除（只是实现方式之一）
（1）带来的问题思考，因为是基于数据库实现的，所以数据库的可用性和性能直接相关影响锁的性能，
因为数据库需要双击部署，主备切换，数据同步，以避免意外情况
（2）不具备可重入性质，即当同一线程再次调用该方法需要进行业务逻辑，由于当前锁未释放，则无法进行重复操作，
因此需要再加一列，记录当前线程信息，每次获取前如果线程信息和当前相同，则直接进入。
 （3） 没有锁失效机制，即当服务宕机时，如果没有释放锁，则数据未删除，当再次进入时，任何线程都无法获取该锁，
redis里面是设置过期时间，然后尝试解决。
（4）不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。
2:基于redis实现
基于setnx加锁，其基本含义是如果redis库中有的话，
三： 分布式事务
由于微信架构的盛行，分布式事务也就随之产生常用的解决方案，
（1）可靠消息最终一致性:
比如基本阿里rocketMq实现，首先a系统首先发送一个准备消息到mq,然后执行a系统本地事务，如果a系统执行失败，那么
告诉mq回滚，如果成功，那么直接通过队列发送消息，如果A系统没有发送确认消息，此时mq会定期轮询所有的prepared
消息，然后调用A系统提供的接口，去确认消息是否执行成功，如果成功，那么就发送确认消息给mq,失败则回滚消息。
 此时B系统收到队列消息，然后执行事务，如果b系统任务执行失败，会基于mq消息不断重试。（互联网公司一般解决方案）
（2）最大努力通知方案：
系统A本地事务执行完以后，发送消息到mq,这里会有个专门消费mq消息的最大努力通知服务，这个服务会消费mq，或者是
写入队列中，然后调用B系统，在有限次内， 比如下单成功后的短信服务，
（3）TCC强一致性：（Try尝试，） （Confirm确认提交） （Cancel 回滚）
 Try 阶段：先把两个银行账户中的资金给它冻结住就不让操作了；
Confirm 阶段：执行实际的转账操作，A 银行账户的资金扣减，B 银行账户的资金增加；
Cancel 阶段：如果任何一个银行的操作执行失败，那么就需要回滚进行补偿，就是比如 A 银行账户如果已经扣减了，
但是 B 银行账户资金增加失败了，那么就得把 A 银行账户资金给加回去。
评价:资金类场景，银行一类，需要大量手写代码逻辑，倾入性太强。
原博地址参考: https://zhuanlan.zhihu.com/p/85790242

