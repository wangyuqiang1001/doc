一:分布式介绍:
1:cap理论:c一致性，a高可用性，p分区容错性，任何分布式系统都只能满足其中两点,
满足ca，即是一致性和高可可用性，牺牲分区容错性子系统（不分区）,(实际上更多的是指分区子系统保持ca)(不分区当前就不需要在各节点之间同步)
满足cp, 即一致性和分区容错性，这样也是可以的，即在各个server之前需要同步保持一致性，传统关系型数据库的分布式事务大于基于此，
满足ap,即高可用性和分区容错性，众多nosql基于此，每个节点只为本地数据提供服务，
2:事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。
3:事务的四大特征:
原子性:构成事务的操作，要么全都执行，要么全都不执行，
一致性:事务执行前后，数据库一致性没有被破坏，A加钱，B减钱，
隔离性：并行发生的事务之间是不可见的。
永久性：事务一旦成功执行，那么便永远存在，且不会回滚
4:事务的类型：
本地事务:更多依赖于关系型数据库自带的事务机制，
分布式事务:更多依赖于服务之间的远程调用协作，如订服务和库存服务，
5:分布式事务产生的场景:
微服务之间的调用
单体系统访问多个数据库实例
多个微服务访问单体系统（对于后两个例子而言，都是一样的，如订单和库存，订单加，库存减少，
单个操作依靠数据库事务是成立的，但是顺序执行就需要考虑事务）
关于cap理论阐述:https://blog.csdn.net/chen77716/article/details/30635543
二：分布式锁:
分布式锁的实现方式:
1:基于关系型强事务支持数据库方式,将方法名作唯一约束，成功插入的方法获取锁，执行完成后删除（只是实现方式之一）
（1）带来的问题思考，因为是基于数据库实现的，所以数据库的可用性和性能直接相关影响锁的性能，
因为数据库需要双击部署，主备切换，数据同步，以避免意外情况
（2）不具备可重入性质，即当同一线程再次调用该方法需要进行业务逻辑，由于当前锁未释放，则无法进行重复操作，
因此需要再加一列，记录当前线程信息，每次获取前如果线程信息和当前相同，则直接进入。
 （3） 没有锁失效机制，即当服务宕机时，如果没有释放锁，则数据未删除，当再次进入时，任何线程都无法获取该锁，
redis里面是设置过期时间，然后尝试解决。
（4）不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。
2:基于redis实现
基于setnx加锁，其基本含义是如果redis库中有的话，