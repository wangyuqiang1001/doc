### redis总结

#### 一：redis简介

支持五种数据类型，比memarche丰富，string , list set zset,  hash五种数据类型，是一个单线程的缓存工具，能支持并发是因为是基于事件驱动的，netty,异步非阻塞，所以不会慢，而且单线程不会有上下文切换开销，同时操作内存效率也很高。redis同时支持持久化。

相比memarche 优点:

1. 不仅支持key-value类型数据，还支持list,set,zset.hash类型数据
2. redis支持数据备份，即master-slave 模式备份
3. 支持将数据持久化到硬盘中，（RDB方式和AOF方式，现在也可以混合）

常用类型存储的数据适用情况:

1. string ：最常用的数据类型，一般的key value 存储都可以归结到此类，支持get ，set等命令，还有incr,decr等命令,同时提供获取字符串长度，往字符串中添加内容分，设置和获取字符串批量位置内容。
2. hash: 常用来作对象存储，以前在memarche中一般需要将整个对象属性写入一个map中，然后通过序列化的方式写入缓存中，但是当涉及到修改的时候，势必要发生序列化和反序列化的过程，但是redis中不会，redis的hash直接提供了hget .hset,hgetall等命令来操作hash数据，当修改时只需要根据比如userId+ 然后field字段名来进行修改，需要注意的是，hgetall在对象内部属性较多时取出该对象全部属性会造成资源损耗过大，在hash数据较少时，会使用一个一位数组来存储数据，当数据量较多时才会转化为map.
3. list: 实现其实是一个双向链表。常用命令：lpush,rpush,lpop,rpop,larange.例如粉丝关注列表，消息队列等都可以基于此来实现。(无法去重，有序)
4. set：常用命令:sadd, spop,smembers, sunion,可以自动去重，还可以判断某个数据是否在set中，应用场景，用户关注的人，并且提供求交集等功能， 可用于共同关注，共同爱好等功能。通过hash计算来实现排重。
5. Sort set：zadd, zrange, zcard等。与set的区别在于，zset可以根据一个预先设定的优先级作为参数来进行排序，并且插入有序，可用来做权重队列。
6. Pub/Su：发布订阅。假设用户对某一个key值进行发布后，所有订阅他的客户端都能收到消息，可用于实时消息系统。

实际常用情况: 定时任务，帖子点赞数（原子递增），消息队列，排行榜前100.

#### 二： redis缓存击穿

1. 缓存击穿: 热点key,突然过期了，并发访问量大，然后直接请求数据库。使用互斥锁，即分布式锁，如果这个数据为空，即代表不存在，setnx,设置从数据库中取到的值，最多有一个线程可以设置，不会出现大并发从Db中访问这个热点key.
2. 缓存穿透: 某个key,一定是不存在的，但是频繁请求，好像穿透了缓存，因为缓存中根本不存在，解决方式，布隆过滤器，将所有可能存在的值hash到一个bitmap中，每次现在这里面查询，如果没有的话就直接返回了。
3. 缓存雪崩：批量key,由于超时时间相近，所以集中过期了。解决方案,为key值设置不同的失效时间，随机数，这样避免了同意时间大批量的失效问题。

#### 三:  redis持久化方式

1. RDB方式和AOF方式，rdb作为全量持久化，aof作增量持久化，即可以理解为rdb中存储了redis的全部数据，但是aof相当于记录了操作日志。

   