1：两个关键字区别
transient修饰的变量，代表该变量不会被序列化，
volatile:代表被改变量在所有线程之间是可见的，每次单个线程去获取之前的话，代表该线程会重新从主存中获取该变量的最新副本。
2：arrayList扩容机制:初始长度为10，开始 ensureCapacityInternal(size + 1)，开始size是0，然后这时size+1是1.，有个计算长度的方法，
如果开始是，默认首次扩容长度是10,当插入第11个数是，这是mincapticy是11.增长， 然后增长方法是当前长度，1.5倍数 a + a >>1,此时
第二次扩容是15,
3: transient Node<K,V>[] table：这是一个Node类型的数组（也有称作Hash桶），
可以从下面源码中看到静态内部类Node在这边可以看做就是一个节点，多个Node节点构成链表，
当链表长度大于8的时候转换为红黑树。
负载因子0.75，初始长度16，当长度超过负载因子，即12时，就会乘2倍。
4: ==和equals的区别
对于基本数据类型而言。相等，没有equals ，对于引用类型而言，引用的是==和equals都是比较地址，但是如果有重写的话，那么就不一样了。
5:jvm:
一:程序计数器：线程独有，作为当前当前线程执行字节码文件的行号指示器，字节码解释器工作时通过改变这个计算器的值，来选取下一条需要执行
的指令。分支，循环，跳转，异常处理等都依赖这个计算器完成。不会出现outofMenoryError错误。
虚拟机栈：虚拟机栈是由一个个栈帧组成的，线程在执行方法时，会向栈中放入一个栈帧，俗称压栈操作，每个栈帧都拥有自己的局部变量表，操作数
栈，方法出口等信息。每个线程拥有各自的虚拟机栈， 并且随线程的创建而创建，死亡而死亡，抛出异常:StackOverFlowError OutOfMemoryError
本地方法栈:虚拟机用到的本地方法服务，同样会创建栈帧，
堆：堆是虚拟机管理内存中最大的一块，java堆是所有线程共享的一块内存区域。几乎所有的对象都在此分配内存,java堆又称GC堆，
新生代:分为Eden空间，From Survivor ,To Survivor,大多数对象在新生代中创建然后被垃圾回收，其中三个区在每次回收后，  年龄加1，Eden
内存已满时，任然存活的对象被放入form survivor .当form survivor中满了以后，此时没未满足晋升的会放入to survivor，晋升年龄阀值通过
MaxTenuringThreshold 设置，默认为15（新生代一般使用复制算法进行垃圾回收）
老年代: 新生代中经过n代任然存活，通常使用标记清-清除法或者是标记整理算法。
永久代: 主要用于元数据，方法区，jdk1.8里面元空间。
方法区： 用来存储被虚拟机加载的类信息，常量，静态变量等，运行时常量池在jdk1.7及以后已经从常量池中移出来了，作为堆的一部分。
6：jvm垃圾判断算法(这里是判断，下面才是清除)
(1)引用计数算法: 堆中每个对象实例都有一个引用计数器，当任意变量的引用指向这个对象时，对象实例的引用计数加1，当一个对象实例的某个引用
超过声明周期或者被设置为一个新的值，对象的引用计数减1，当引用计数器为0是代表该对象可以被回收，当该对象被回收时，比如A引用了B,
A被回收了，那么B的引用计数器减少1，缺点是:如果相互引用的话，那么就存在无法回收。(jvm早期策略)
(2): 可达性分析算法: 
基于离散数学图的概念，从一系列"GC ROOTS"对象作为根起点进行搜索，如果一个对象从这个根起点是不可达的，那么至少经过两次才能被回收。
可以被作为“GC ROOTS”的节点:
1: 虚拟机栈中引用的对象（比如方法内的局部变量）
2: 方法内的全局静态对象: (类的静态对象，)
3: 常量引用：(类的静态final对象)
具体实际的GC过程对应:
1:第一次标记
当第一次标记为不可达时，如果该对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，对象将在第二次标记以后被回收。
2:第二次标记
如果对象有必要执行finalize()方法，即对象重写了finalize方法，将对象放置在f-queue中，虚拟机自动建立一条低优先级的线程去执行，
对象可以在f-queue中进行第二次标记时，在finalize（）方法中将当前对象重新建立引用关系，否则会被回收。
参考博客:https://blog.csdn.net/luzhensmart/article/details/81431212
3:复制算法
为了解决句柄开销和内存碎片问题，开始时把堆分为一个对象面和多个空闲面，程序从对象面为对象分配内存空间，当对象满了时，
基于cpoying算法的垃圾回收从根节点扫描活动对象，并将活动对象复制到空闲面，这样空闲面就变成了活动面，
4:标记清除法
从根集合进行扫描，对存活的对象进行标记，再扫描整个空间中未标记的对象，进行回收，由于不移动对象，会造成
内存碎片。
5:标记整理法
和标记清除算法的区别在于，在整理了清除回收对象以后，会对对象进行移动，因为成本较高，但是却解决了内存碎片的问题。
7:java的四种引用方式
（1）强引用: User u = new User(); 《永远不会被垃圾回收，除非不可达，比如再执行操作 u = null》
（2）软引用: 可用于网页缓存，图片缓存，在内存不够时会被jvm垃圾回收。（new SoftReference<>）
（3）弱引用：无论jvm内存是否足够，一旦jvm开始垃圾回收都会被清除 (new WeakReference<>(buff))
（4）虚引用: 相当于没有引用，任何时候都可以被回收。
8:GC是什么时候触发的
1:Scavenge gc 
当对象在Eden区域申请内存空间失败时，代表空间不够，需要GC
2: Full gc 
完整的GC
出现在以下情况:
（1）年老代被写满
（2） 持久代被写满
（3）system.gc被显式调用
（4）上一次GC以后各域分配策略动态变化

