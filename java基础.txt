1：两个关键字区别
transient修饰的变量，代表该变量不会被序列化，
volatile:代表被改变量在所有线程之间是可见的，每次单个线程去获取之前的话，代表该线程会重新从主存中获取该变量的最新副本。
2：arrayList扩容机制:初始长度为10，开始 ensureCapacityInternal(size + 1)，开始size是0，然后这时size+1是1.，有个计算长度的方法，
如果开始是，默认首次扩容长度是10,当插入第11个数是，这是mincapticy是11.增长， 然后增长方法是当前长度，1.5倍数 a + a >>1,此时
第二次扩容是15,
3: transient Node<K,V>[] table：这是一个Node类型的数组（也有称作Hash桶），
可以从下面源码中看到静态内部类Node在这边可以看做就是一个节点，多个Node节点构成链表，
当链表长度大于8的时候转换为红黑树。
负载因子0.75，初始长度16，当长度超过负载因子，即12时，就会乘2倍。
4: ==和equals的区别
对于基本数据类型而言。相等，没有equals ，对于引用类型而言，引用的是==和equals都是比较地址，但是如果有重写的话，那么就不一样了。
5:jvm:
一:程序计数器：线程独有，作为当前当前线程执行字节码文件的行号指示器，字节码解释器工作时通过改变这个计算器的值，来选取下一条需要执行
的指令。分支，循环，跳转，异常处理等都依赖这个计算器完成。不会出现outofMenoryError错误。
虚拟机栈：虚拟机栈是由一个个栈帧组成的，线程在执行方法时，会向栈中放入一个栈帧，俗称压栈操作，每个栈帧都拥有自己的局部变量表，操作数
栈，方法出口等信息。每个线程拥有各自的虚拟机栈， 并且随线程的创建而创建，死亡而死亡，抛出异常:StackOverFlowError OutOfMemoryError
本地方法栈:虚拟机用到的本地方法服务，同样会创建栈帧，
堆：堆是虚拟机管理内存中最大的一块，java堆是所有线程共享的一块内存区域。几乎所有的对象都在此分配内存,java堆又称GC堆，
新生代:分为Eden空间，From Survivor ,To Survivor,大多数对象在新生代中创建然后被垃圾回收，其中三个区在每次回收后，  年龄加1，Eden
内存已满时，任然存活的对象被放入form survivor .当form survivor中满了以后，此时没未满足晋升的会放入to survivor，晋升年龄阀值通过
MaxTenuringThreshold 设置，默认为15
老年代: 新生代中经过n代任然存活，通常使用标记清-清理法。
永久代: 主要用于元数据，方法区，jdk1.8里面元空间。
方法区： 用来存储被虚拟机加载的类信息，常量，静态变量等，运行时常量池在jdk1.7及以后已经从常量池中移出来了，作为堆的一部分。

