1存储引擎
Mysql常见的两种存储引擎: mylsam 和innoDB
两者区别: innodb支持事务，mylsam不支持，innodb支持外键，mylsam不支持，innodb使用的是聚集索引，数据文件和索引绑定在一起，
B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值，mylsam使用的非聚集索引，索引的叶子节点文件是数据文件的地址指针。
2字符集校对规则
字符集校对规则指的是二进制编码到某字符符号的映射，mysql采用额是类似继承的方式制定字符集默认值，
每个数据库以及每张表都有自己的默认值，逐层继承。
3索引
按照种类分
(1普通索引:仅仅为了加快查询效率，
(2)唯一索引:加速查询 + 列值唯一（可以有null)
(3)主键索引：加速查询+ 列值为一（不可以存在null）+ 表中只有一个
主键索引，即在mysql表创建时就会为主键添加一个唯一索引，而单纯的唯一索引主键中可以有多个。
(4)组合索引: 多个列值组成一个索引，专门用于组合搜索，其效率大于索引合并，
索引合并，即使用多个单列索引进行组合搜索，覆盖索引，select中的数据列只用从索引中取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。
(5)全文索引:对文本中的内容进行分词，进行搜索，
4 mysql事务
关系型数据库acid
(1)A;原子性 事务是最小的执行单位，不允许分割，事务中的操作，要么全部完成，要么全部失败
(2)C:一致性 事务执行前后数据保持一致
(3)I：隔离性事务并发执行期间，事务之间是隔离互不干扰的
(4)D: 持久性 一个事务被提交以后，它在数据库中的改变时持久的，
脏读(读取未提交数据)A事务读取到了B事务尚未提交的数据，这很明显是有问题的，一旦A事务发生回滚，那么数据就错了
幻想读(前后多次读取，数据总量不一致，事务A需要两次统计总条数，在第一次统计完成以后，B事务插入了一条数据，A事务读取到的
数据总条数加了一条，这样仿佛A事务幻想读取到了数据，个人认为幻想读关系不大)
不可重复读(A事务比如获取小明age是30岁，然后进行其他操作，同时B事务更新小明年龄为20岁，此时A事务再次都小明年龄，此时是20岁，这样发生了不可重复读，
即数据前后不一致了，无法读取到重复的数据)
不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
5 mysql事务隔离级别
(1)READ_UNCOMMITTED未授权读取：最低隔离级别，允许读取到其他事务尚未提交的数据，，可能会导致脏读，幻读，不可重复读，
(2)READ_COMMITTED 授权读取，允许读取并发事务已经提交的数据，可以防止脏读，但是幻读和不可重复度仍然会出现，
(3)REPEATABLE_READ 可重复读，对同一字段的多次读取结果都是一致的，除非是被本身事务所修改，可以阻止脏读和不可重复读，但是幻读仍然有可能发生。
(4)SERIALIZABLE 串行 完成服从acid隔离级别，所有的事务一次逐个执行，这样事务之间完全不会产生干扰，也就是说可以防止重复读，幻读，脏读，但是严重
影响程序性能。
Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.
6 锁
mylsam采用表锁,innodb支持表锁和行级锁，默认为行级锁
表锁: Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。
其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。
其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
7 大表优化
读写分离，缓存，垂直分表，即


