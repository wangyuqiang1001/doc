1spring事务的配置方式
(1)编程式事务（手写实现编程时事务，代码侵入性较强，使用TransactionTemplate或者是PlatformTransactionManager，spring推荐前者）
(2)声明式事务
基于spring aop实现，其本质是对方法前后进行拦截在目标方法创建之前加入一个事务，然后执行完目标方法之后根据执行情况回滚或者是提交。
总结:编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，
不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。
显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。
唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。
2事务的传播机制
(1)PROPAGATION_REQUIRED： spring默认事务传播机制，能满足大部分需求，如果外层有事务，则把当前事务加入外层事务一块提交一块回滚，如果
外层没有事务则新建一个事务执行。
(2)PROPAGATION_REQUES_NEW: 每次都会开启一个新事务，同时把外层事务挂起，当前代码执行完毕，恢复上层事务执行。
(3)PROPAGATION_SUPPORT: 完全依赖外层事务，外层有就有，没就没。
(4)PROPAGATION_NOT_SUPPORT: 该传播机制不支持事务，内层事务不支持事务。无论内层是否异常都不会回滚。
(5)PROPAGATION_NEVER: 该传播机制不支持外层事务，如果外层有事务就抛出异常。
(6)PROPAGATION_MANDATORY: 和never相反，如果外层没有事务，那么抛出异常。
(7)该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，
即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。
传播规则回答了这样一个问题：一个新的事务应该被启动还是被挂起，或者是一个方法是否应该在事务性上下文中运行。
3spring事务隔离级别
相对而言只是增加了一个默认隔离级别，这个默认的隔离级别就是当前DB的隔离级别。
4乐观锁悲观锁
(1)悲观锁:每次总是假设最坏的情况，即认为获取数据的时候别人会修改，所以在拿数据的时候都上锁，（如关系型数据库行锁，表锁，可重如锁均有运用该思想）
(2)乐观锁:每次总假设最好的情况，即认为每次拿数据的时候别人不会修改，所以不会上锁，适用于多读的情况，原子变量类是基于乐观锁试的一种实现方式CAS实现的。
5 Synchronized与ReentrantLock
两者都是悲观锁，但是Synchronized是非公平锁，ReentrantLock可以实现公平锁。
